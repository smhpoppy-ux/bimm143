---
title: "class 7: machine learning"
author: "sylvia ho a18482382"
format: pdf
---
##bg
clustering, dimensionality reduction

##k means clustering
"clusters"
`rnorm()`

```{r}
hist(rnorm(5000))
```

```{r}
rnorm(30,mean=3)
```

```{r}
tmp<- c(rnorm(30, mean = 3),
        rnorm(30, mean = -3))
x<-cbind(x=tmp, y=rev(tmp))
plot(x)
```

##k means clustering
`kmeans()`

```{r}

km<-kmeans(x, centers= 2)
```

```{r}
km$size
```
centers
```{r}
km$centers
```

membership
```{r}
km$cluster
```

```{r}
plot(x, col=c(1,2))
```

`kmeans()` 4 clusters and figure

```{r}
tmp <- c(rnorm(30, mean = 3),
         rnorm(30, mean = -3),
         rnorm(30, mean = 0), 
         rnorm(30, mean = 6))
x <- cbind(x = tmp, y = rev(tmp))
k4 <- kmeans(x, centers = 2)
plot(x, col = k4$cluster)
```

```{r}
km$tot.withinss
k4$tot.withinss
```

```{r}

ans<-NULL
for(i in 1:30){
ans <- c(ans, kmeans(x,centers = i)$tot.withinss)
}

```

```{r}
plot(ans,typ="o")
```
**key pt** k means will impose clustering structure on ata even if not there

##hierarchical clusteral
main fn `hclust()` unlike kmeans (does allw ork for u) hclust needs a "distance matrix" like returned from `dist()` fn could be seq id, anything

```{r}
d<-dist(x)
hc<-hclust(d)
plot(hc)
```

cut tree to uilt drp grps / branches to extract cluster membershp vector

```{r}
plot(hc)
abline(h=8, col="red", lty=2)
```

```{r}
cutree(hc,h=8)
```
## pca of uk food data

```{r}
url <- "https://tinyurl.com/UK-foods"
x <- read.csv(url)
```

```{r}
dim(x)
```

```{r}
rownames(x) <- x[,1]
x <- x[,-1]
head(x)
```
better read csv
```{r}

x<-read.csv(url,row.names=1)
x
```

```{r}
rainbow(4)
```

```{r}
barplot(as.matrix(x), beside=T, col=rainbow(nrow(x)))

```

```{r}

library(tidyr)

# Convert data to long format for ggplot with `pivot_longer()`
x_long <- x |> 
          tibble::rownames_to_column("Food") |> 
          pivot_longer(cols = -Food, 
                       names_to = "Country", 
                       values_to = "Consumption")

dim(x_long)
```

```{r}
library(ggplot2)

```

```{r}
ggplot(x_long) +
  aes(x = Country, y = Consumption, fill = Food) +
  geom_col(position = "dodge") +
  theme_bw()
```

```{r}
pairs(x, col=rainbow(nrow(x)), pch=16)

```


```{r}
library(pheatmap)

pheatmap( as.matrix(x) )
```
main pca fn in base r is `prcomp()` fn wants transpose of food data asinput (food as cols and countries as rows)

```{r}
pca <- prcomp( t(x) )
summary(pca)
```
`pca$x` scores along w new pcs, called pc plot or score plot, ordination plot

```{r}
df <- as.data.frame(pca$x)
df$Country <- rownames(df)

ggplot(pca$x) +
  aes(x = PC1, y = PC2, label = rownames(pca$x)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.5) +
  xlim(-270, 500) +
  xlab("PC1") +
  ylab("PC2") +
  theme_bw()
```

```{r}
v <- round( pca$sdev^2/sum(pca$sdev^2) * 100 )
v
```
```{r}
attributes(pca)
```
loadings plot
```{r}
ggplot(pca$rotation) +
  aes(x = PC1, 
      y = reorder(rownames(pca$rotation), PC1)) +
  geom_col(fill = "steelblue") +
  xlab("PC1 Loading Score") +
  ylab("") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 9))
```


```{r}
url2 <- "https://tinyurl.com/expression-CSV"
rna.data <- read.csv(url2, row.names=1)
head(rna.data)
```
```{r}
pca <- prcomp(t(rna.data), scale=TRUE)

# Create data frame for plotting
df <- as.data.frame(pca$x)
df$Sample <- rownames(df)

## Plot with ggplot
ggplot(df) +
  aes(x = PC1, y = PC2, label = Sample) +
  geom_point(size = 3) +
  geom_text(vjust = -0.5, size = 3) +
  xlab("PC1") +
  ylab("PC2") +
  theme_bw()
summary(pca)

```
percent var
```{r}
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)

# Create scree plot data
scree_df <- data.frame(
  PC = factor(paste0("PC", 1:10), levels = paste0("PC", 1:10)),
  Variance = pca.var[1:10]
)

ggplot(scree_df) +
  aes(x = PC, y = Variance) +
  geom_col(fill = "steelblue") +
  ggtitle("Quick scree plot") +
  xlab("Principal Component") +
  ylab("Variance") +
  theme_bw()
```
```{r}

scree_pct_df <- data.frame(
  PC = factor(paste0("PC", 1:10), levels = paste0("PC", 1:10)),
  PercentVariation = pca.var.per[1:10]
)

ggplot(scree_pct_df) +
  aes(x = PC, y = PercentVariation) +
  geom_col(fill = "steelblue") +
  ggtitle("Scree Plot") +
  xlab("Principal Component") +
  ylab("Percent Variation") +
  theme_bw()
```


```{r}
colvec <- colnames(rna.data)
colvec[grep("wt", colvec)] <- "red"
colvec[grep("ko", colvec)] <- "blue"

# Add condition to data frame
df$condition <- substr(df$Sample, 1, 2)
df$color <- colvec

ggplot(df) +
  aes(x = PC1, y = PC2, color = color, label = Sample) +
  geom_point(size = 3) +
  geom_text(vjust = -0.5, hjust = 0.5, show.legend = FALSE) +
  scale_color_identity() +
  xlab(paste0("PC1 (", pca.var.per[1], "%)")) +
  ylab(paste0("PC2 (", pca.var.per[2], "%)")) +
  theme_bw()
```


















